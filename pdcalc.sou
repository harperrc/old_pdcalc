*cd basicd
      common /basicd/ iseed
c
*cd const
      real*4 recm4,grav4,we4
      common /const/ pi,twopi,dpr,re,cmf,piovr2,xmu,re2,zero,one,twoxmu,
     * cnm2ft,ckm2ft,we,bk,forpi3,pi886,forpi2,cghz2ft,third,pi2thd,
     * piovr4,rekm,xmusqr,g0,ttol,small,ckm2ft2,cft2cm2,rkp100,rkp1002,
     * twore,cx0,recm,grav,pi2ov4,pi2o16,trpio4,pi4th,rftp100,ohnft,
     * cm2ft,spdlig,rekp120,half,sqr2pi,recm4,grav4,we4
c
*cd files
      common /files/ lin,lout,ldbg
c
*cd real8
      implicit real*8 (a-h,o-z)
c
*dk main
      program main
*ca real8
      character*132 fname,gname
      character*1 jti,kfi
*ca basicd
*ca const
*ca files
      dimension pd(2)
c
c  cep   circular error probable for weapon (km)
c  r95   95% of damage radius lies within this area (km)
c  gname file name containing ground range, altitude and yield data
c  ivns  starting vn #
c  ivne  ending vn #
c  ivnd  step in vn #
c  jti   target type
c  kfi   k-factor
c  iflg  see pdcalc
c  mode  which read to use
c  gamma reentry angle assumed 
c
      namelist /simlst/ cep,r95,gname,ivns,ivne,ivnd,jti,kfi,iflg,
     *  mode,gamma
c
      lin=1
      lout=6
      ldbg=6
c
      open (unit=lout,status='unknown',name='pdcalc.out')
c
      if(ldbg.ne.lout) then
         open (unit=ldbg,status='unknown',name='pdcalc.dbg')
      endif
c
      if(iargc().gt.0) then
         call getarg(1,fname)
         open (unit=lin,status='old',name=fname)
      else
         open (unit=lin,status='old',name='pdcalc.inp')
      endif
c
      call acon
c
      ivns=23
      ivne=23
      ivnd=1
c
      jti='z'
      kfi='0'
      ifl=2
c
      cep=zero
      r95=zero
c
      mode=1
c
      gamma=-1.0
c
      read(lin,simlst)
      write(lout,simlst)
c
      close (unit=lin)
c
c  convert to feet
c
      cep=cep*ckm2ft
      r95=r95*ckm2ft
c
c  convert r95 to nautical miles
c
      r95=r95/cnm2ft
c
      gamma=gamma/dpr
c
c  open file with info
c
      open (unit=1,status='old',name=gname)
c
      smalpk=1.0e-8
c
      open (unit=2,status='unknown',name='pdcalc.dat')
c
      if(mode.eq.2) then
         goto 333
      else
         write(2,25)
      endif
c
 111  read(1,*,end=222)grn,hob,yld
c
c  for y and z target types force ground bursts
c
      if(jti.eq.'z'.or.jti.eq.'y')hob=zero
c
      grf=grn*ckm2ft
      hof=hob*ckm2ft
c
      d=grf/cnm2ft
c
      do 100 iv=ivns,ivne,ivnd
c
c  compute pd with and without cep effects
c
      do j=1,2
         if(j.eq.1) then
            xcep=zero
            xr95=zero
         else
            xcep=cep
            xr95=r95
         endif
c
         call pdcalc(iv,jti,kfi,yld,hof,xr95,xcep,d,wr,pod,ifl,az)
c
         pd(j)=pod
      enddo
c
c  limit to smalpk for iplot use
c
      do j=1,2
         pd(j)=max(smalpk,pd(j))
      enddo
c
c  compute scaled range
c
      scl=sqrt(grn*grn+hob*hob)/yld**third
c
      write(2,30)scl,wr/ckm2ft,pd
c
 100  continue
c
      goto 111
 222  close (unit=1)
c
      close (unit=lout)
      close (unit=2)
c
      stop
c
 333  read(1,40,end=444)grn,hob,yld,iv,jti,kfi
c
c  force hob = 0 for crater targets...add in approximation
c  if tgt flown to ground
c
      if(jti.eq.'y'.or.jti.eq.'z') then
         if(gamma.gt.zero)grn=grn+hob/tan(gamma)
         hob=zero
      endif
c
      grf=grn*ckm2ft
      hof=hob*ckm2ft
c
      d=grf/cnm2ft
c
      xr95=zero
      xcep=zero
c
      call pdcalc(iv,jti,kfi,yld,hof,xr95,xcep,d,wr,pod,ifl,az)
c
      write(2,50)grn,hob,yld,iv,jti,kfi,wr/ckm2ft,pod
c
      goto 333
 444  close (unit=1)
c
      close (unit=lout)
      close (unit=2)
c
      stop
c
 20   format(3(1x,f12.3),3(1x,f12.7))
 25   format('4',/,
     *  'gr (scaled) km',/,
     *  'wr',/,
     *  'pd',/,
     *  'pd(cep)')
 30   format(4(1x,f15.8))
 40   format(3f10.3,i5,a,a)
 50   format(3(1x,f10.3),1x,i5,1x,a,1x,a,2(1x,f12.5))
c
      end
*dk errmsg
      subroutine errmsg(ierr,iv,jt,kf,yld,cep,hob1,r95,d,wr,pod,iflg)
*ca real8
*ca const
*ca files
      if(iflg.eq.5.or.iflg.eq.6)d=zero
      if(iflg.ne.9.and.iflg.ne.10)wr=zero
      if(iflg.ne.5.and.iflg.ne.6)pod=zero
c
      goto (10,20,30,40,50,60,70,80,90,100,110,120),ierr
c
 10   write(ldbg,11)
 11   format(' you cannot achieve desired pod with this weapon')
      goto 999
 20   write(ldbg,21)
 21   format(' vn is too large to use for available data curves')
      goto 999
 30   write(ldbg,31)
 31   format(' shob > 900 ft')
      goto 999
 40   write(ldbg,41)
 41   format(' only options with eta tgts are iflg=1 or 2')
      goto 999
 50   write(ldbg,51)
 51   format(' t of vntk must be an x when iflg=7')
      goto 999
 60   write(ldbg,61)
 61   format(' k for this type of vntk must be < 10')
      goto 999
 70   write(ldbg,71)
 71   format(' k of personnel vntk must be 1-9 or a-q')
      goto 999
 80   write(ldbg,81)
 81   format(' k of special crater cases must be 1-9 or a-p')
      goto 999
 90   write(ldbg,91)
 91   format(' t of vntk is not a valid character')
      goto 999
 100  write(ldbg,101)
 101  format(' crater required by z or y..... contact burst needed')
      goto 999
 110  write(ldbg,111)
 111  format(' k of vntk must specify a fatality curve for iflg=7')
      goto 999
 120  write(ldbg,121)
 121  format(' shob > 1000 ft')
c
 999  shob=hob1/yld**third
      write(ldbg,1000)iv,jt,kf,yld,cep,hob1,r95,d,wr,pod,iflg,shob
 1000 format(' iv: ',i3,' jt: ',i2,' kf: ',i2,' yld: ',f10.3,/,
     *  ' cep: ',f10.3,' hob1: ',f10.3,' r95: ',f10.3,' d: ',f10.3,/,
     *  ' wr: ',f10.3,' pod: ',f10.6,' iflg: ',i8,' shob: ',f10.3,/)
      return
      end
*dk etcalc
      subroutine etcalc(iv,jt,kf,yld,cep,hob1,orien,azmth,di,pod,wr,
     *  ierr)
c
c  compute probability of damage for equivalent target area (eta) type 
c  targets
c
c  inputs
c        iv     vulnerability number
c        jt     target type
c        kf     k-factor
c        yld    weapon yield (kt)
c        cep    circular error probable (feet)
c        hob1   height of burst (feet)
c        orien  
c        azmth
c
c  inputs/outputs
c        d      distance from dgz to target
c        pod    probability of damage
c        wr     weapon radius
c        ierr   error status
c
*ca real8
*ca const
*ca files
      dimension inw(3,10,6),crw(10,6),dswv(10,6),vnw(10,6),
     *  inl(6,10,6),crl(2,10,6),dslv(2,10,6),vnl(10,6)
c
      dd(b,c)=abs(b)/(1.414213562*c)
c
      er(b,c)=one+dd(b,c)*(w1+dd(b,c)*(w2+dd(b,c)*(w3+dd(b,c)*
     *  (w4+dd(b,c)*(w5+dd(b,c)*w6)))))
c
      erfp(b,c)=(one-(one/er(b,c))**16)*abs(b)/(2.0*b)
c
      p(b,c,d,e,f,g,h,a)=(erfp(d,e)-erfp(b,c))*(erfp(h,a)-erfp(f,g))
c
      acep(a,b)=sqrt(cep*cep+(1.1774*a*b)**2)/1.1774
c
      data inw/
c
c  bridges
c
     *  0,0,0,  0,0,0,  0,0,0, 31,1,0, 25,2,6, 20,2,6, 18,2,6, 25,2,8,
     * 15,2,9, 16,2,8,  0,0,0, 18,2,9, 17,2,9, 16,2,8, 15,2,9, 17,2,8,
     * 14,2,9, 16,2,9, 16,2,9,  0,0,0, 
     * 18,2,9, 17,2,9, 16,2,8, 15,2,9, 16,2,9, 17,2,8, 17,2,8, 9*0,
c
c  dams (upstream vntk)
c
     * 41,1,0, 38,1,0, 38,1,0, 42,1,0, 39,1,0, 39,1,0, 39,1,0, 35,1,0,
     * 35,1,0,  0,0,0,
c
c  locks
c
     *  30*0,
c
c  special case
c
     *  0,0,0, 13,2,5, 11,2,4, 21*0/
c
      data crw/
c
c  bridges
c
     *  1.5,2.0,1.5,27*0.,
c
c  dams (upstream)
c
     *  9*0.,1.0,
c
c  locks
c
     *  1.0,1.5,1.0,1.5,1.0,1.5,4*0.,
c
c  special case
c
     *  10*0./
c
      data inl/
c
c  bridges
c
     * 18*0,       38,1,4*0,   29,2,6,3*0, 23,2,6,3*0, 21,2,6,3*0,
     * 29,2,8,3*0, 18,2,9,3*0, 22,2,8,9*0, 22,2,9,3*0, 20,2,9,3*0,
     * 19,2,8,3*0, 21,2,7,3*0, 23,2,8,3*0, 23,2,7,3*0, 25,2,8,3*0,
     * 24,2,8,9*0, 22,2,8,3*0, 22,2,8,3*0, 22,2,8,3*0, 23,2,7,3*0,
     * 25,2,8,3*0, 23,2,7,3*0, 25,2,8,21*0,
c
c  dams (downstream vntk)
c
     *  60*0,
c
c  locks
c
     * 12*0, 31,1,4*0, 31,1,4*0, 31,1,0, 31,1,0, 31,1,0, 31,1,25*0,
c
c  special case
c
     * 6*0, 13,2,5, 3*0, 11,2,4, 45*0/
c
      data crl/
c
c  bridges
c
     * 1.25,0.,1.5,0.,1.25,0.,34*0.,
     * 20*0.,
c
c  dams (downstream crf)
c
     * 0.5,0.,0.5,0.,0.5,0.,0.5,0.,0.5,0.,0.5,0.,0.5,0.,0.5,0.,0.5,0.,
     * 1.5,0.,
c
c  locks
c
     * 2*1.,2*1.5,0.0,1.0,0.0,1.5,12*0.,
c
c  special case
c
     *  20*0./
c
      data dswv/
c
c  bridges
c
     *  3*0.3,0.2,6*0.3,0.0,8*0.3,0.0,
     *  7*0.3,3*0.,
c
c  dams (upstream dsig)
c
     *  9*0.2,0.3,
c
c  locks
c
     *  6*0.3,4*0.,
c
c  special case
c
     *  0.0,0.3,0.3,7*0./
c
      data dslv/
c
c  brigdes
c
     * .3,0.,.3,0.,.3,0.,.2,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,
     * 0.,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,0.,0.,
     * .3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,7*0.,
c
c  dams (downstream dsig)
c
     * 0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,0.,.3,
c
c  locks
c
     * 4*0.3,0.2,0.3,0.2,0.3,4*0.2,8*0.,
c
c  special case
c
     *  2*0.,0.3,0.,0.3,0.,14*0./
c
      data vnw/
c
c  bridges
c
     *  5.,15.,25.,35.,45.,55.,65.,75.,85.,90.,
     *  5.,15.,25.,35.,45.,55.,65.,75.,85.,90.,
     *  5.,15.,25.,35.,45.,55.,65.,75.,85.,90.,
c
c  dams
c
     *  5.,15.,26.,40.,57.,82.,114.,163.,229.,262.,
c
c  locks
c
     *  33.,40.,60.,75.,90.,110.,125.,145.,180.,200.,
c
c  special case
c
     *  2000.,1900.,1700.,1500.,1300.,1100.,900.,700.,500.,300./
c
      data vnl/
c
c  bridges
c
     *  50.,150.,400.,800.,1200.,1600.,2000.,2400.,2800.,3000.,
     *  50.,150.,400.,800.,1200.,1600.,2000.,2400.,2800.,3000.,
     *  50.,150.,400.,800.,1200.,1600.,2000.,2400.,2800.,3000.,
c
c  dams
c
     *  500.,750.,1500.,2500.,3500.,4500.,7500.,12500.,20000.,25750.,
c
c  locks
c
     *  98.,130.,250.,500.,800.,1300.,2000.,2450.,2800.,3000.,
c
c  special case
c
     *  10000.,9500.,8500.,7500.,6500.,5500.,4500.,3500.,2500.,2000./
c
      data w1,w2,w3,w4,w5,w6/
     *  0.0705230784,0.0422820123,0.0092705272,0.0001520143,
     *  0.0002765672,0.0000430638/
c
      ierr=0
c
      igv=iv/10
      ign=iv-igv*10
c
      wrl1=zero
      wrl2=zero
      wrw1=zero
c
      kk=kf+1
c
      if(ign.eq.0)ign=10
      if(igv.eq.0)igv=10
c
      jts=jt
      goto (100,110,110,300,200,400),jts
      write(lout,*)' goto error in etcalc ',jts
      stop' got error'
c
c  jts to 1 or 2 or 3 for bridges
c
c  if air-burst for a0,a1 or a2 type bridges set pod to zero
c
 100  if(kf.lt.3.and.hob1.gt.0.99)goto 500
c
c  determine weapon radii
c
c  see if crater or non-crater
c
 110  if(crl(1,kk,jts).gt.zero) then
         call wrcrtr(yld,crl(1,kk,jts),wrl1,jts,kf)
      endif
      if(inl(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inl(1,kk,jts),inl(2,kk,jts),
     *      inl(3,kk,jts),dslv(1,kk,jts),wrl1,ierr)
      endif
c
      if(crw(kk,jts).gt.zero) then
         call wrcrtr(yld,crw(kk,jts),wrw1,jts,kf)
      endif
      if(inw(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inw(1,kk,jts),inw(2,kk,jts),
     *      inw(3,kk,jts),dswv(kk,jts),wrw1,ierr)
      endif
c
c  determine x and y offset distances
c  orien is the target direction
c  azmth is the azimuth from dgz to target
c  xo is the east-west component
c  yo is the north-south component
c
      ddum=di*cnm2ft
      angle=(azmth-orien*10.0)/dpr
      xo=ddum*sin(angle)
      yo=ddum*cos(angle)
c
c  compute boundaries
c
      w=vnw(ign,jts)
      sl=vnl(igv,jts)
c
      a=-w/2.0-wrw1+xo
      b= w/2.0+wrw1+xo
      c=-sl/2.0-wrl1+yo
      d= sl/2.0+wrl1+yo
c
c  compute delivery sigmas
c
      aa=acep(wrw1,dswv(kk,jts))
      ab=aa
      ac=acep(wrl1,dslv(1,kk,jts))
      ad=ac
c
c  compute pod
c
      pod=p(a,aa,b,ab,c,ac,d,ad)
      return
c
c  lock section
c
c  if air-burst set pod to zero
c
 200  if(hob1.gt.0.001)goto 500
c
c   determine weapon radii
c
      if(crl(1,kk,jts).gt.zero) then
         call wrcrtr(yld,crl(1,kk,jts),wrl1,jts,kf)
      endif
      if(inl(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inl(1,kk,jts),inl(2,kk,jts),
     *      inl(3,kk,jts),dslv(1,kk,jts),wrl1,ierr)
      endif
      if(crl(2,kk,jts).gt.zero) then
         call wrcrtr(yld,crl(2,kk,jts),wrl2,jts,kf)
      endif
      if(inl(5,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inl(4,kk,jts),inl(5,kk,jts),
     *      inl(6,kk,jts),dslv(1,kk,jts),wrl2,ierr)
      endif
      if(crw(kk,jts).gt.zero)crw(kk,jts)=-crw(kk,jts)
      if(crw(kk,jts).lt.zero) then
         call wrcrtr(yld,crw(kk,jts),wrw1,jts,kf)
      endif
      if(inw(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inw(1,kk,jts),inw(2,kk,jts),
     *     inw(3,kk,jts),dswv(kk,jts),wrw1,ierr)
      endif
c
      wr=(wrl2-wrl1)/2.0
      if(inl(2,kk,jts).gt.0)wr=(wrl1-wrl2)/2.0
c
c  determine x and y offset distances
c  orien is the target direction
c  azmth is the azimuth from dgz to target
c  xo is the east-west component
c  yo is the north-south component
c
      ddum=di*cnm2ft
      angle=(azmth-orien*10.0)/dpr
      xo=ddum*sin(angle)
      yo=ddum*cos(angle)
c
c  compute boundaries
c
      w=vnw(ign,jts)
      sl=vnl(igv,jts)
c
      a=-w/2.0-wrw1+xo
      b= w/2.0+wrw1+xo
c
      aa=acep(wrw1,dswv(kk,jts))
      ab=aa
c
      if(inl(2,kk,jts).gt.0)goto 210
c
      c=-sl/2.0-wrl1+yo
      d= sl/2.0+wrl2+yo
c
      ac=acep(wrl1,dslv(1,kk,jts))
      ad=acep(wrl2,dslv(2,kk,jts))
      goto 220
c
 210  c=-sl/2.0-wrl2+yo
      d= sl/2.0+wrl1+yo
      ac=acep(wrl2,dslv(2,kk,jts))
      ad=acep(wrl1,dslv(1,kk,jts))
c
 220  poc=p(a,aa,b,ab,c,ac,d,ad)
      return
c
c  dam section
c
c  jts = 4 for dams
c
 300  if(hob1.gt.0.001)goto 500
c
c  determine weapon radii
c
      if(crl(1,kk,jts).gt.zero)crl(1,kk,jts)=-crl(1,kk,jts)
      if(crl(1,kk,jts).lt.zero) then
         call wrcrtr(yld,crl(1,kk,jts),wrl1,jts,kf)
      endif
      if(inl(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inl(1,kk,jts),inl(2,kk,jts),
     *      inl(3,kk,jts),dslv(1,kk,jts),wrl1,ierr)
      endif
      if(crw(kk,jts).gt.zero) then
         call wrcrtr(yld,crw(kk,jts),wrw1,jts,kf)
      endif
      if(inw(2,kk,jts).gt.0) then
         call wrcalc(yld,hob1,inw(1,kk,jts),inw(2,kk,jts),
     *      inw(3,kk,jts),dswv(kk,jts),wrw1,ierr)
      endif
c
      wr=(wrw1-wrl1)/2.0
c
c  determine x and y offset distances
c  orien is the target direction
c  azmth is the azimuth from dgz to target
c  xo is the east-west component
c  yo is the north-south component
c
      ddum=di*cnm2ft
      angle=(azmth-orien*10.0)/dpr
      xo=ddum*sin(angle)
      yo=ddum*cos(angle)
c
c  compute boundaries
c
      w=vnw(ign,jts)
      sl=vnl(igv,jts)
c
      c=-sl/2.0+yo
      d= sl/2.0+yo
      if(kf.eq.9)goto 310
c
      a=-wrw1-0.10+xo
      b= wrl1-0.10+xo
      goto 320
c
 310  a=-wrw1+w/2.0+xo
      b= wrl1-w/2.0+xo
c
 320  aa=acep(wrw1,dswv(kk,jts))
      ab=acep(wrl1,dslv(2,kk,jts))
      ac=acep(sl/2.0,dslv(1,kk,jts))
      ad=ac
c
      pod=p(a,aa,b,ab,c,ac,d,ad)
c
      if(pod.lt.zero)goto 500
      return
c
c  special case section
c
 400  call wrcalc(yld,hob1,inl(1,kk,jts),inl(2,kk,jts),inl(3,kk,jts),
     *  dslv(1,kk,jts),wrl1,ierr)
c
      wrw1=wrl1
c
c  determine x and y offset distances
c  orien is the target direction
c  azmth is the azimuth from dgz to target
c  xo is the east-west component
c  yo is the north-south component
c
      ddum=di*cnm2ft
      angle=(azmth-orien*10.0)/dpr
      xo=ddum*sin(angle)
      yo=ddum*cos(angle)
c
c  compute boundaries
c
      w=vnw(ign,jts)
      sl=vnl(igv,jts)
c
      a=-w/2.0-wrw1+xo
      b= w/2.0+wrw1+xo
      c=-sl/2.0-wrl1+yo
      d= sl/2.0+wrl1+yo
c
      aa=acep(wrw1,dswv(kk,jts))
      ab=aa
      ac=acep(wrw1,dslv(1,kk,jts))
      ad=ac
c
      pod=p(a,aa,b,ab,c,ac,d,ad)
      return
c
 500  pod=zero
c
      return
      end
*dk intgf
      subroutine intgf(z,r,x,f)
*ca real8
*ca const
      rx=r*x
      if(rx.gt.3.75)goto 111
c
      ts=0.071111111*(rx*rx)
      f=(r*exp(-0.50*(r*r+x*x)))*(one+ts*(3.5156229+ts*
     *  (3.0899424+ts*(1.2067492+ts*(0.2659732+ts*(0.0360768+
     *  ts*0.0045813))))))
      if(z.le.3.87)goto 222
      return
c
 111  ti=3.75/rx
      f=0.51639778*r*exp(-0.50*(x-r)**2)*sqrt(ti)*
     *  ((((((((0.00392377*ti-0.01647633)*ti+0.02635537)*ti
     *  -0.02057706)*ti+0.00916281)*ti-0.00157565)*ti
     *  +0.00225319)*ti+0.01328592)*ti+0.39894228)
      if(z.gt.3.87)return
c
 222  sign=one
      if(z.lt.zero)sign=-one
c
      u=0.70710678*abs(z)
      f=f*(0.50+0.50*sign*(one-one/
     *  ((one+u*(0.278393+u*(0.230389+u*(0.000972+u*0.078108))))**4)))
c
      return
      end
*dk lncalc
      subroutine lncalc(cep,dsig,wr,r95,pod,d,iflg,ierr)
c
c  compute the probability of damage or calculate the offset distance
c  to acheive a specific probability of damage.
c
c  inputs:
c      cep    circular error probable (feet)
c      dsig   damage sigma
c      wr     weapon radius (feet)
c      r95    95 % radius
c
c  inputs/outputs
c      pod    probability of damage
c      d      distance from dgz to target (nmi)
c      iflg   options flag
c             = 1 limit pod <=0.99
c             = 2 limit pod <=0.999
c             = 6 set d = zero
c      ierr   error status
c
*ca real8
      logical cross
*ca const
*ca files
      dimension w(5),zp(5)
c
      data w/0.0666713443,0.1494513492,0.2190863625,0.2692667193,
     *  0.2955242247/
c
      data zp/0.9739065285,0.8650633667,0.6794095683,0.4333953941,
     *  0.1488743390/
c
      ierr=0
c
      if(iflg.eq.6)d=zero
      d=d*cnm2ft
      itch=0
c
      rr5=r95*cnm2ft
c
      adcep=sqrt(cep*cep+0.231*rr5*rr5)
c
      if(wr.le.0.001)goto 40
c
c  compute beta-factor used in computing z
c
 10   ex=one-dsig*dsig
      beta=sqrt(-log(ex))
c
      if(adcep.gt.zero)goto 50
c
c  compute pod when cep=r95=zero
c
c  if d = zero set pod = 0.999
c
      if(d.le.zero)goto 20
c
      z=(one/beta)*log(wr*ex/d)
c
c  if z >3.87 pod = 0.999.  if z is close to zero pod = 0.50
c  if z < -3.87 pod = zero
c
      if(z.gt.3.87)goto 20
      zab=abs(z)
      if(zab.lt.5.0e-7)goto 30
      if(z.lt.-3.87)goto 40
c
c  pod = 0.50+0.50*abs(z)/z*erf(1)
c
      c=abs(z)/1.414213562
c
      c2=c*c
      c3=c2*c
      c4=c3*c
      c5=c4*c
      c6=c5*c
c
      erfu=one-one/((one+0.0705230784*c+0.0422820123*c2+
     *  0.0092705272*c3+0.0001520143*c4+0.0002765672*c5+
     *  0.0000430638*c6)**16)
c
      if(z.lt.zero) then
         pov=0.50-0.50*erfu
      else
         pov=0.50+0.50*erfu
      endif
c
      goto 120
c
 20   pov=0.999
      goto 120
c
 30   pov=0.500
      goto 130
c
 40   pov=zero
      goto 130
c
c  normalize wr and d
c
 50   wrn=1.1774*wr/adcep
      x  =1.1774*d/adcep
c
c  fsum will sum terms of gaussian quadrature
c
      fsum=zero
c
c  if dn - 4 < 0 begin integration with radius of zero otherwise at dt-4
c
      xbb=1.06*wrn*exp(2.86*dsig)
c
      xb=x+4.0
c
      if(xbb.lt.xb)xb=xbb
c
      if(x.le.4.0) then
         xa=zero
         bplusa=xb
         bminsa=xb
      else
         xa=x-4.0
         bplusa=xa+xb
         bminsa=xb-xa
         if(bminsa.le.zero)goto 110
      endif
c
 90   wrnx=wrn*ex
      betai=one/beta
c
      do 100 n=1,5
c
      r1=(-bminsa*zp(n)+bplusa)/2.0
      r2=( bminsa*zp(n)+bplusa)/2.0
c
      z1=betai*log(wrnx/r1)
      z2=betai*log(wrnx/r2)
c
      call intgf(z1,r1,x,f)
      fsum=fsum+w(n)*f
      if(z2.lt.-3.87)goto 100
      call intgf(z2,r2,x,f)
      fsum=fsum+w(n)*f
 100  continue
 110  continue
c
      pov=0.50*fsum*bminsa
c
 120  if(iflg.eq.6)goto 140
      if(pov.le.0.99)goto 130
      if(iflg.eq.1)pov=0.99
      if(pov.gt.0.999)pov=0.999
c
 130  pod=pov
c
      d=d/cnm2ft
c
      return
c
c  this is where computation of d, offset distance, occurs if it is
c  desired.  this computes the max distance at which a given minimum
c  pod can be obtained
c
 140  if(itch.gt.0)goto 150
      if(pov.lt.pod)goto 180
c
      itch=1
c
      acc=0.001
      cross=.false.
      dd=wr
      d=wr
      goto 10
c
 150  pda=abs(pod-pov)
      if(pda.lt.acc)goto 170
      if(pod.gt.pov)goto 160
      if(cross)dd=dd/2.0
      d=d+dd
      goto 10
c
 160  cross=.true.
      dd=dd/2.0
      d=d-dd
      goto 10
c
 170  d=d/cnm2ft
      return
c
 180  ierr=1
      d=zero
c
      return
      end
*dk pdcalc
      subroutine pdcalc(iv,jti,kfi,yld,hob1,r95,cep,d,wr,pod,iiflg,
     *   azmth)
c
c  compute damage levels or associated values
c
c  inputs
c    iv      vulnerability number or target dimensions for equivalent
c            target area (eta) type targets
c    jti     target type (character*1)
c            valid (r,s,q,t,u,l,p,m,n,o,z,y,a,b,c,d,e,f,x)
c    kfi     k-factor  (character*1)
c            (0-9 for p and q type)
c            (a-p for x type)
c   yld      weapon yield (kt)
c   hob1     height of burst of weapon (feet)
c   r95      radius of a circle encompassing 95 percent of the 
c            circular normal target area (nmi)
c            for eta targets r95*10 = orientation of the target (degrees)
c   cep      circular error probable of the specified weapon system (feet)
c
c  inputs/outputs
c   d        distance from dgz to target (nmi)
c   wr       weapon radius (feet)
c   pod      probability of achieving the specified level of damage
c   iiflg    control flag
c
c    value     function              vntk             (d)       (pod)     (wr)
c    -----     --------              ----            -----      ------    ------
c      1   compute pod and wr        all             input      output    output
c          (max pod = 0.99)
c
c      2   compute pod and wr        all             input      output    output
c          (max pod = 0.999)
c
c     3,4  compute wr                not eta         input        na      output
c
c     5,6  compute d and wr          not eta         output     input     output
c
c      7   compute fatalities and    "x" only        input      output    output
c          casualties                                           (fatl)    (casu)
c
c      8   compute pod and wr        not eta         input      in-dsig   output
c                                                               out-pod
c
c      9   compute pod               all             input      in-pod    in-wr
c                                                               out-pod   out-wr
c
c   azmth   azimuth in degrees from dgz to target
c              
*ca real8
      character*1 jt,kft,kfi,jti,kfn,jtd
*ca const
*ca files
c
      dimension ddsig(19),jjtd(19),kfn(27),kff(27),jtd(19)
c
      data jtd  /'r','s','q','t','u','l','p','m','n','o',
     *           'z','y','a','b','c','d','e','f','x'/
      data jjtd/  2 , 2 , 2 , 2 , 2 , 1 , 1 , 1 , 1 , 1,
     *            4 , 4 , 5 , 6 , 7 , 8 , 9 ,10 , 3/
      data ddsig/.1 , .2, .3, .4, .5, .1, .2, .3, .4, .5,
     *           .3 , .3, 1., 1., 1., 1., 1., 1., 1./
c
      data kfn/'0','1','2','3','4','5','6','7','8','9','a','b',
     *  'c','d','e','f','g','h','i','j','k','l','m','n','o','p','q'/
      data kff/ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 ,
     *   3 , 4 , 5 , 6 , 7 , 8 , 9 , 10, 11, 12, 13, 14, 15, 16, 17/
c
c  convert to lower case
c
      ich=ichar(jti)
      if(ich.gt.64.and.ich.le.90) then
         jt=char(ichar(jti)+32)
      else
         jt=jti
      endif
c
      ich=ichar(kfi)
      if(ich.gt.64.and.ich.le.90) then
         kft=char(ichar(kfi)+32)
      else
         kft=kfi
      endif
c
c  get target type
c
      do i=1,19
         if(jt.eq.jtd(i)) then
            jjt=jjtd(i)
            dsig=ddsig(i)
            goto 10
         endif
      enddo
c
      ierr=9
      goto 990
c
c  get kf (numeric)
c
 10   do i=1,27
         if(kft.eq.kfn(i)) then
            kf=kff(i)
            goto 11
         endif
      enddo
c
      ierr=9
      goto 990
c
 11   ifhflg=0
      ifgflg=0
c
      iflg=iiflg
c
      if(iflg.gt.1000)ifhflg=1
      if(iflg.gt.1000)iflg=iflg-1000
      if(iflg.gt.100)ifgflg=1
      if(iflg.gt.100)iflg=iflg-100
      if(iflg.eq.3)iflg=4
      if(iflg.eq.5)iflg=6
c
      iflh=iflg
c
c  iflg of 7 must have a 'x' vntk
c
      if(iflg.ne.7)goto 14
c
c  'x' vn number
c
      if(jjt.eq.3)goto 100
c
      ierr=5
      goto 990
c
 14   if(jjt.gt.2)goto 100
c
c  overpressure, dynamic pressure and crater type vn's
c
 15   if(iflg.eq.8.or.iflg.eq.9)dsig=pod
      if(iflg.ge.9)goto 20
c
      call wrcalc(yld,hob1,iv,jjt,kf,dsig,wr,ierr)
      if(ierr.ne.0)goto 990
c
 19   if(iflg.ne.4)goto 20
      pod=zero
      return
c
 20   call lncalc(cep,dsig,wr,r95,pod,d,iflh,ierr)
      if(ierr.ne.0)goto 990
      return
c
 100  if(jjt.le.4)goto 200
c
c  eta type vntk
c
      if(iflg.le.2)goto 110
c
      ierr=4
      goto 990
c
 110  jts=jjt-4
c
      call etcalc(iv,jts,kf,yld,cep,hob1,r95,azmth,d,pod,wr,ierr)
      if(ierr.ne.0)goto 990
      return
c
c  check for and process 'x', 'y', and 'z' type vntk
c
 200  if(jt.ne.'z')goto 210
      jjt=1
c
      if(hob1.le.0.99)goto 15
c
      ierr=10
      goto 990
c
 210  if(jt.eq.'x')goto 225
      if(hob1.le.0.99)goto 220
c
 220  call wrclcy(kf,yld,wr,ierr)
      if(ierr.eq.0)goto 19
c
c  invalid jt='y' vntk; set pod,wr and or d to zero and return
c
      if(iflg.eq.6)d=zero
      if(iflg.ne.9.and.iflg.ne.10)wr=zero
      if(iflg.ne.6)pod=zero
      return
c
 225  iflh=2
      if(iflg.ne.7)goto 230
      kk=kf/2*2
      if(kf.ne.kk)goto 230
      ierr=11
      goto 990
c
 230  call wrpers(yld,hob1,iv,jjt,kf,dsig,wr,ierr)
      if(ierr.ne.0)goto 990
      if(iflg.eq.4)return
c
      call lncalc(cep,dsig,wr,r95,pod,d,iflh,ierr)
      if(ierr.ne.0)goto 990
      if(iflg.ne.7)return
c
      if(kf/2*2.eq.kf)goto 231
      p1=pod
      kf=kf+1
      goto 230
c
 231  wr=pod
      pod=p1
      return
c
 990  if(ifhflg.eq.1.and.ierr.eq.10)goto 991
      if(ifgflg.eq.1.and.ierr.eq.2)goto 991
c
      call errmsg(ierr,iv,jjt,kf,yld,cep,hob1,r95,d,wr,pod,iflg)
      return
c
 991  if(iflg.eq.5.or.iflg.eq.6)d=zero
      if(iflg.ne.9.and.iflg.ne.10)wr=zero
      if(iflg.ne.3.and.iflg.ne.6)pod=zero
c
      return
      end
*dk wrcalc
      subroutine wrcalc(yld,hob1,iv,jjt,kf,dsig,wr,ierr)
c
c  compute weapon radius for p (overpressure) or q (dynamic pressure)
c  targets
c
c  inputs
c        yld   weapon yield (kt)
c        hob1  height of burst (feet)
c        iv    vulnerability number
c        jjt   target type 
c              1-p
c              2-q
c        kf    yield adjustment factor (0-9)
c        dsig  damage sigma
c
c  outputs:
c        wr    weapon radius (feet)
c        ierr  error status flag
*ca real8
*ca const
*ca files
      dimension wp(8,2,10),wq(8,10),tvnp(9),tvnq(9),wp1(88),wp2(72),
     *  wq1(72),wq2(8)
c
      equivalence (wp(1),wp1(1)),(wp(89),wp2(1)),(wq(1),wq1(1)),
     *  (wq(73),wq2(1))
c
c  coefficients for 7th order polynomial approximation for weapon
c  radius coputations
c
      data wp1/8.206936,-0.09866222,-0.004270532,0.00044673610,4*0.,
     *  8.26343,-0.12109524,0.00127466,-0.9206549e-5,4*0.,
     *  8.29123,-0.1132939,0.3119908e-3,5*0.,
     *  8.29959,-0.1104334,-0.48494085e-3,0.658301e-4,-0.91680378e-6,
     *  3*0.,
     *  8.395223,-0.14717856,0.01274489,-0.002063277,0.1667591e-3,
     *  -0.689342e-5,0.1423714e-6,-0.11675015e-8,
     *  8.395223,-0.14717856,0.01274489,-0.002063277,0.1667591e-3,
     *  -0.689342e-5,0.1423714e-6,-0.11675015e-8,
     *  8.41958,-0.09982782,-0.0041872797,0.5449084e-3,-0.3758352e-4,
     *  0.1400969e-5,-0.2107989e-7,0.,  
     *  8.41958,-0.09982782,-0.0041872797,0.5449084e-3,-0.3758352e-4,
     *  0.1400969e-5,-0.2107989e-7,0.,  
     *  8.499489,-0.1096521,-0.003444575,0.7261706e-3,-0.710905e-4,
     *  0.3319013e-5,-0.5668505e-7,0.,
     *  8.499489,-0.1096521,-0.003444575,0.7261706e-3,-0.710905e-4,
     *  0.3319013e-5,-0.5668505e-7,0.,
     *  8.525985,-0.06312055,-0.02562219,0.005426447,-0.5926339e-3,
     *  0.3485504e-4,-0.1022865e-5,0.114432e-7/
c
      data wp2/8.525985,-0.06312055,-0.02562219,0.005426447,
     *  -0.5926339e-3,0.3485504e-4,-0.1022865e-5,0.114432e-7,
     *  8.586222,-0.1002711,-0.009917176,0.00260232,-0.3602822e-3,
     *  0.2802515e-4,-0.1082636e-5,0.1541557e-7,
     *  8.586222,-0.1002711,-0.009917176,0.00260232,-0.3602822e-3,
     *  0.2802515e-4,-0.1082636e-5,0.1541557e-7,
     *  8.655962,-0.1367989,0.01426281,-0.004092999,0.5028125e-3,
     *  -0.2571224e-4,0.4379003e-6,0.,
     *  8.655962,-0.1367989,0.01426281,-0.004092999,0.5028125e-3,
     *  -0.2571224e-4,0.4379003e-6,0.,
     *  8.681285,-0.1143286,-0.001788869,0.1595909e-3,4*0.,
     *  12.51342,-1.516344,0.1769944,-0.008900835,0.1400736e-3,3*0.,
     *  8.719654,-0.1215853,0.001203604,-0.1386328e-3,4*0.,
     *  13.47289,-1.971983,0.2547267,-0.014325115,0.2640371e-3,3*0./
c
      data wq1/8.315159,-0.106087,0.5224e-3,-0.313e-3,0.32265e-4,
     *  -0.123227e-5,0.196707e-7,-0.105880e-9,
     *  8.376082,-0.104295,-0.0012014,-0.391136e-4,0.128757e-4,
     *  -0.497579e-6,0.577257e-8,0.,
     *  8.42024,-0.109473,0.001462288,-0.596972e-3,0.6697002e-4,
     *  -0.3014946e-5,0.6188228e-7,-0.4866633e-9,
     *  8.485315,-0.103139,-0.0034114,0.3087e-3,-0.107267e-4,
     *  0.315662e-6,-0.556646e-8,0.,
     *  8.576,-0.103989,-0.0065788,0.0012382,-0.1333e-3,0.801387e-5,
     *  -0.234684e-6,0.251295e-8,
     *  8.6435,-0.1110564,-0.0041904,0.6644e-3,-0.776848e-4,
     *  0.598695e-5,-0.227079e-6,0.300626e-8,
     *  8.686697,-0.116482,0.3634e-3,-0.6169e-3,0.857541e-4,
     *  -0.407263e-5,0.566502e-7,0.,
     *  8.70745,-0.117550,0.0023483,-0.0013054,0.1909e-3,-0.1152e-4,
     *  0.283079e-6,-0.244704e-8,
     *  8.736328,-0.1151805,0.0021175,-0.0015218,0.2654e-3,-0.19675e-4,
     *  0.618015e-6,-0.720562e-8/
c
      data wq2/8.793042,-0.1154885,0.1871e-3,-0.0011008,0.2357e-3,
     *  -0.201562e-4,0.69752e-6,-0.874866e-8/
c
c  yield limits for p targets
c
      data tvnp/54.,51.,34.,30.,27.,27.,22.,21.,20./
c
c  yield limits for q targets
c
      data tvnq/35.,35.,35.,31.,28.,26.,25.,23.,22./
c
      ierr=0
c
      if(kf.ge.10) then
         ierr=6
         return
      endif
c
      jt=jjt
      vn=iv
      fk=kf
c
      yldcu=yld**third
      yldic=one/yldcu
c
      shob=hob1*yldic
      ds2=one/(one-dsig*dsig)
c
      fk10=fk*0.10
c
      sil=shob/100.0+1.0001
      il=sil
      il=max(1,il)
c
      if(il.ge.10) then
         ierr=3
         return
      endif
c
      fac=(il-1)*100.0
      fac=(shob-fac)/100.0
c
c  check for p or q
c
      if(jt.eq.1)goto 240
c
c  calculate the adjusted vn for q type targets
c
      r2=3.0
c
 10   r1=one-fk10*(one-2.7144176*yldic*(r2**third))
      abdif=r1-r2
      r2=r1
      abdif=abs(abdif)
      if(abdif.gt.0.001)goto 10
c
      avn=vn+2.742*log(r2)
      ax=1.10
c
c  compute wr for q type targets
c
      if(avn.gt.tvnq(il)) then
         ierr=2
         return
      endif
c
      swrl=wq(1,il)+avn*(wq(2,il)+avn*(wq(3,il)+avn*(wq(4,il)+
     *  avn*(wq(5,il)+avn*(wq(6,il)+avn*(wq(7,il)+avn*wq(8,il)))))))
      ih=il+1
      swrh=wq(1,ih)+avn*(wq(2,ih)+avn*(wq(3,ih)+avn*(wq(4,ih)+
     *  avn*(wq(5,ih)+avn*(wq(6,ih)+avn*(wq(7,ih)+avn*wq(8,ih)))))))
      goto 300
c
c  calculate the adjusted vn for p type targets
c
 240  r2=2.0
c
 11   r1=one-fk10*(one-2.7144176*yldic*(r2**0.50))
      abdif=r1-r2
      r2=r1
      abdif=abs(abdif)
      if(abdif.gt.0.001)goto 11
c
      avn=vn+5.485*log(r2)
      ax=1.04
c
c  compute wr for p type targets
c
      if(avn.gt.tvnp(il)) then
         ierr=2
         return
      endif
c
      if(avg.lt.36.0)goto 260
c
c  functional fit to high vn range
c
      shck=-9.0*avn+560.0
      if(shob.gt.shck) then
         ierr=2
         return
      endif
c
c  calculate wr using the AIM fit
c
      vx=(avn-46.0)/10.0
      wo=88.0-vx*(53.0-vx*(21.0-vx*8.0))
      if(shob.ne.zero)goto 259
c
      wr=wo*yldcu*ds2/ax
      goto 400
c
 259  hm=70.0-5.0*vx*(7.0-vx)
      con=1.6+0.20*vx
      hx=shob/hm
      dw=wm-wo
      wr=wo+dw*hx*(2.0-hx-con*(one-hx)**2)
      wr=wr*yldcu*ds2/ax
      goto 400
c
c  use the table data
c
 260  j=1
      if(avn.gt.7.5)j=2
      swrl=wp(1,j,il)+avn*(wp(2,j,il)+avn*(wp(3,j,il)+avn*(wp(4,j,il)+
     *  avn*(wp(5,j,il)+avn*(wp(6,j,il)+avn*(wp(7,j,il)+avn*wp(8,j,il))
     *  )))))
      ih=il+1
      swrh=wp(1,j,ih)+avn*(wp(2,j,ih)+avn*(wp(3,j,ih)+avn*(wp(4,j,ih)+
     *  avn*(wp(5,j,ih)+avn*(wp(6,j,ih)+avn*(wp(7,j,ih)+avn*wp(8,j,ih))
     *  )))))
c
 300  swrl=exp(swrl)
      swrh=exp(swrh)
      wr=(swrl+fac*(swrh-swrl))*yldcu*ds2/ax
c
 400  if(wr.lt.zero)wr=zero
c
      return
      end
*dk wrclcy
      subroutine wrclcy(kf,yield,wr,ierr)
c
c  compute weapon radius for special crated type targets
c
c  inputs
c     kf      which crater weapon radius equation to use
c             (1-17)
c     yield   weapon yield (kt)
c
c  output
c     wr      weapon radius (feet)
c     ierr    error status
c
*ca real8
*ca const
*ca files
      dimension ycof(17),yexp(17)
c
      data ycof/28.,89.,131.,136.,140.,141.,146.,148.,155.,185.,
     *  209.,214.,219.,229.,230.,231.,232./
      data yexp/.546,.381,.352,.357,.324,.323,.323,.325,.375,.367,
     *  .333,.338,.334,.311,.321,.310,.316/
c
      ierr=0
      if(kf.lt.1.or.kf.gt.17) then
         ierr=7
         return
      endif
c
c  compute weapon radius
c
      wr=ycof(kf)*yield**yexp(kf)
c
      return
      end
*dk wrcrtr
      subroutine wrcrtr(yld,crf,wr,jts,kf)
c
c  compute weapon radius for etcalc when a crater radius factor (crf)
c  is given.
c
c  inputs
c        yld    weapon yield (kt)
c        crf    crater radius factor
c        jts    target type
c        kf     k-factor
c
c  outputs
c        wr     weapon radius (feet)
c
*ca real8
*ca const
      soilcf=61.0
      if(jts.eq.4.and.kf.eq.9.and.crf.gt.zero)soilcf=82.0
      if(jts.eq.5.and.crf.gt.zero)soilcf=82.0
      if(jts.eq.4.and.kf.lt.9)soilcf=58.0
      if(crf.lt.zero)crf=-crf
c
      wr=1.1*crf*soilcf*yld**0.30
c
      return
      end
*dk wrpers
      subroutine wrpers(yld,hob1,iv,jjt,kf,dsig,wr,ierr)
c
c  compute weapon radius for personnel
c
c  inputs
c    yld      weapon yield (kt)
c    hob1     height of burst (feet)
c    iv       vulnerability number (not used)
c    jjt      target type (not used)
c    kf       k-factor (1-16 [corresponds to a-p])
c                                       fatalities casualties any injury
c                                       ---------- ---------- ----------
c      wood framed buildings                1(a)      2(b)
c      single story buildings
c      wall bearing buildings
c      adobe buildings
c      forests
c
c      multistory residential               3(c)      4(d)
c      commercial or industrial buildings
c      steel or reinforced concrete framed
c
c      basements                            5(e)      6(f)
c
c      deliberate underground shelters      7(g)      8(h)
c
c      expedient underground shelters       9(i)     10(j)
c
c      open urban or open rural             11(k)    12(l)
c
c      exposed thermal                      13(m)    14(n)
c
c      underground command post             15(o)    15(o)
c
c      urban                                                    16(p)
c 
c
c    dsig     damage sigma
c    wr       weapon radius (feet)
c  
*ca real8
*ca const
*ca files
      dimension s(6),t(6),nm(16),li(39),lk(40),a(32),b(32),ch(562),
     *  ch1(64),ch65(60),ch125(53),ch178(69),ch247(70),ch317(72),
     *  ch389(48),ch437(42),ch479(42),ch521(42)
c
      equivalence (ch1(1),ch(1)),(ch65(1),ch(65)),(ch125(1),ch(125)),
     *  (ch178(1),ch(178)),(ch247(1),ch(247)),(ch317(1),ch(317)),
     *  (ch389(1),ch(389)),(ch437(1),ch(437)),(ch479(1),ch(479)),
     *  (ch521(1),ch(521))
c
      data s(1),t(1)/1.0,1.0/
      data nm/1,4,6,9,11,14,16,19,22,25,26,30,32,35,38,39/
      data li/3,4,4,4,4,3,4,4,4,4,5,3,4,4,4,5,4,3,5,4,
     *        3,6,5,3,5,5,4,3,3,3,5,6,4,4,6,4,4,6,6/
      data lk/0,12,24,36,52,64,76,88,100,112,124,144,153,165,177,
     *  189,214,234,246,271,283,292,316,336,348,373,388,400,406,
     *  412,421,436,454,466,478,496,508,520,544,562/
c
      data ch1/538.1,-39.5,-52.1,-30.9,422.2,-62.4,-62.8,-52.4,
     *  44.1,-14.8,-17.6,-18.9,
     *  1706.3,197.2,-107.1,3334.9,1036.8,142.0,1031.1,76.8,-121.8,
     *  621.6,181.0,28.2,
     *  5055.6,-4552.1,1862.5,-11696.7,22289.7,-8102.4,5038.9,-5562.1,
     *  2274.4,-4369.0,7269.2,-2684.7,
     *  3591.6,1515.9,399.9,361.3,5127.9,2364.2,666.0,586.1,2195.9,
     *  1099.2,351.0,310.6,464.2,240.9,92.1,83.0,
     *  3116.5,710.2,-49.3,6719.7,1755.5,-137.0,1756.3,399.1,-26.4,
     *  1169.2,300.3,-26.0/
c
      data ch65/511.1,-44.2,-26.3,3.3,343.5,-72.1,-23.4,-2.7,15.9,
     *  -18.1,-4.5,-2.9,
     *  1475.7,427.2,35.2,2369.8,478.3,52.6,903.1,375.9,34.1,448.2,
     *  -9.2,-29.5,
     *  310.6,2224.8,-581.9,2943.8,-1062.7,-21.9,-8.5,1901.6,-363.2,
     *  1264.4,-1308.1,397.0,
     *  3195.1,1464.3,279.8,4503.0,2298.3,470.8,1964.7,1091.7,264.4,
     *  435.5,246.5,63.6,
     *  2821.6,604.3,-59.2,5935.3,1618.3,-94.5,1602.9,328.2,-40.1,
     *  1034.0,278.1,-12.7/
c
      data ch125/1496.5,372.6,78.3,3.3,1956.8,577.2,119.2,-16.9,943.8,
     *  332.0,60.6,-12.6,356.8,100.3,9.6,-0.1,64.6,-7.0,-10.9,-0.8,
     *  881.3,-535.8,38.3,874.4,-804.2,65.8,190.8,-278.2,27.7,1418.4,
     *  835.9,660.6,-1473.6,3950.5,-3648.9,757.4,1053.0,696.5,204.4,
     *  143.8,-410.1,1816.8,303.2,-209.0,2265.0,448.0,-314.6,847.8,
     *  187.3,-154.1,171.7,30.8,-39.2/
c
      data ch178/2213.5,430.9,-71.5,4457.7,1154.4,-15.5,1173.5,253.9,
     *  -54.2,801.4,184.7,-3.7,-247.8,-1234.0,-621.2,-148.2,20.3,
     *  -767.2,-2067.6,-1033.6,-256.2,45.1,-635.7,-1202.3,-612.5,-150.9,
     *  38.7,-262.0,-471.1,-247.6,-53.9,22.1,-53.3,-102.6,-55.0,-9.2,
     *  7.2,-3617.0,-7824.1,-6433.1,-3799.1,-1141.6,4213.8,8832.9,
     *  11023.7,8211.2,2830.5,-3966.9,-7719.2,-6392.5,-3806.3,-1134.1,
     *  1178.4,2731.0,3395.8,2551.9,901.9,-27720.8,-49305.0,-27982.8,
     *  -8218.3,37489.9,65058.5,37703.2,11270.9,-10966.7,-19824.7,
     *  -11131.7,-3256.3/
c
      data ch247/325.1,-986.7,-741.7,-416.4,-133.5,220.1,-1491.4,
     *  -1118.4,-648.9,-199.0,45.5,-667.7,-525.6,-318.0,-94.5,
     *  63.3,-179.0,-158.5,-98.5,-32.0,27.7,-29.7,-30.3,-18.5,-7.3,
     *  931.3,-1252.0,-164.1,1034.8,-1886.8,-295.4,257.1,-793.2,
     *  -208.7,20.8,-148.6,-77.5,2312.0,-1951.4,-451.1,1267.0,
     *  -2232.0,1482.1,1773.7,-1609.5,-173.8,
     *  448.3,-307.1,-101.0,-17.3,405.8,-524.7,-179.0,-57.8,139.1,
     *  -192.5,-69.9,-38.8,193.9,143.2,75.4,13.5,130.6,149.2,72.1,18.5,
     *  4.0,-5.9,-10.4,-3.7/
c
      data ch317/-1092.0,659.2,-1525.0,630.3,-2302.9,1343.1,-2677.2,
     *  1136.4,-1705.2,1128.3,-1753.1,784.3,-799.2,669.9,-816.3,392.0,
     *  -212.7,225.3,-222.2,114.6,5145.1,-7147.4,3164.7,-144.9,-6229.4,
     *  9549.0,-4581.7,897.3,2352.1,-2946.0,1198.2,192.0,1552.9,252.5,
     *  -60.7,-68.7,-26.5,2096.1,382.0,-78.9,-108.1,-34.9,915.6,181.8,  
     *  -36.2,-48.5,-13.6,297.0,46.3,-14.0,-11.8,-4.9,58.0,3.1,-3.5,
     *  -2.1,-1.5,2495.8,530.8,-39.0,3584.0,836.7,-50.3,1716.9,392.1,
     *  -40.2,521.7,91.8,-18.6,72.1,11.0,0.6/
c
      data ch389/883.9,2319.7,-538.2,989.4,3616.8,-790.9,447.4,1590.4,
     *  -267.7,152.6,297.2,-14.8,-30638.8,43111.4,43828.5,-52525.1,
     *  -24879.6,34686.8,8664.5,1263.4,-5289.4,-1069.9,5902.9,777.7,
     *  869.2,161.4,-26.6,804.6,224.6,-23.8,153.1,73.8,-4.8,4188.7,
     *  1085.1,-67.6,5210.5,1195.5,-112.9,3268.1,949.0,-43.5,616.9,
     *  72.4,-21.8,277.0,116.9,6.2/
c
      data ch437/2763.7,475.7,-92.8,4165.0,879.8,-158.0,1998.9,624.0,
     *  -105.5,678.7,313.1,-53.3,180.8,100.1,-14.4,39.1,16.6,2.3,54.4,
     *  -3019.6,-1270.6,-71.6,-4518.7,-1848.7,-159.0,-1967.7,-751.6,
     *  -59.9,-416.8,-144.4,358367.6,520343.9,165511.7,-559255.1,
     *  -822777.0,-263079.9,291463.4,424061.4,135192.3,-65192.0,
     *  -96277.0,-31131.7/
c
      data ch479/3659.6,809.4,-118.7,5515.8,1458.8,-210.0,2638.5,
     *  1003.0,-140.6,891.8,489.0,-68.2,241.5,148.3,-13.4,55.1,21.0,
     *  8.1,-55.5,-4178.2,-1704.7,-312.6,-6309.3,-2497.8,-351.8,
     *  -2809.3,-1034.0,-131.2,-620.8,-206.6,505974.8,734336.1,
     *  232815.5,-792454.4,-1163833.9,-370734.3,413597.8,601382.9,
     *  191085.0,-94345.2,-138879.9,-44740.8/
c
      data ch521/195.8,-56.9,-34.1,-6.7,249.7,-154.1,-105.2,-33.7,
     *  144.2,-2.3,0.3,2.5,22.0,-45.5,-32.6,-12.0,16.8,12.1,9.4,4.2,
     *  -0.1,-5.3,-3.9,-1.1,4604.8,1135.1,-84.1,6750.2,1763.8,-118.9,
     *  3250.3,840.2,-60.1,984.3,241.6,-15.9,196.7,64.9,-0.2,57.1,
     *  23.5,-1.5/
c
      data a/1.6,2.3,0.75,1.6,0.25,0.9,1.6,1.5,1.7,-0.5,0.55,3.7,2.79,
     *  1.35,2.15,-1.3,2.0,2.79,0.225,3.99,1.0,1.5,2.2,-0.4,0.7,1.55,
     *  0.8,1.2,1.8,-2.0,0.9,1.6/
      data b/-0.00071,-0.000999,0.0005,0.0,-0.000249,-0.00055,-0.000749,
     *  -0.00067,-0.00053,0.0024,-0.0005,-0.00233,0.00071,0.00175,
     *  -0.00225,0.0035,0.00175,-0.0022,0.0035,-0.00229,-0.00067,
     *  -0.00067,-0.00087,0.0012,0.0004,0.0,-0.00055,-0.00045,-0.00055,
     *  0.0,-0.0006,-0.00065/
c
      ierr=0
c
      if(kf.gt.16) then
         ierr=8
         return
      endif
c
      yldcu=yld**third
      shob=hob1/yldcu
c
      wr=zero
      dsig=0.30
c
      xl=log10(yld)
c
      x=(xl+one)/2.65052-one
      y=shob/500.0-one
c
      if(kf.eq.15)y=shob/200.0-one
c
      if(abs(x).le.one.and.abs(y).le.one)goto 46
      ierr=12
      return
c
 46   s(2)=x
      t(2)=y
c
      do l=3,6
         s(l)=2.0*x*s(l-1)-s(l-2)
         t(l)=2.0*y*t(l-1)-t(l-2)
      enddo
c
      n=nm(kf)
      goto (101,102,103,104,105,106,107,108,109,110,111,112,113,
     *  113,115,116),kf
c
 101  ks=2
      if(shob.gt.700.0)ks=4
      if(yld.lt.10.0)goto 142
      n=n+1
      if(shob.ge.800.0)n=n+1
      goto 142
c
 102  ks=6
      if(yld.gt.10.0)n=n+1
      goto 141
c
 103  if(yld.le.10.0)goto 200
      n=n+1
      if(shob.gt.700.0)n=n+1
      goto 200
c
 104  ks=8
      if(yld.gt.10.0)n=n+1
      goto 143
c
 105  ks=9
      if(shob.gt.750.0)ks=10
      if(shob.le.700.0)goto 144
      n=n+1
      if(yld.gt.40.0)n=n+1
      goto 144
c
 106  ks=11
      if(yld.gt.10.0)n=n+1
      goto 144
c
 107  ks=12
      if(shob.gt.300.0)ks=13
      if(yld.gt.100.0)n=n+1
      if(yld.ge.2000.0)n=n+1
      goto 144
c
 108  ks=14
      if(shob.gt.200.0)ks=15
      if(shob.gt.600.0)ks=16
      if(shob.lt.700.0)goto 144
      n=n+1
      if(yld.gt.200.0)n=n+1
      goto 144
c
 109  ks=17
      if(shob.gt.200.0)ks=18
      if(shob.gt.450.0)ks=19
      if(shob.gt.650.0)ks=20
      if(shob.lt.500.0)goto 144
      n=n+1
      chk=0.53-0.50*y
      if(yld.le.700.0.and.x.lt.chk)goto 144
      if(shob.gt.800.0)return
      n=n+1
      goto 144
c
 110  dsig=0.40
      goto 200
c
 111  ks=22
      if(shob.gt.750.0)ks=25
      if(yld.gt.200.0)goto 121
      if(shob.ge.800.0)n=n+1
      goto 141
c
 121  if(shob.lt.900.0)goto 141
      n=n+2
      if(yld.ge.1000.0)n=n+1
      goto 141
c
 112  ks=28
      if(yld.gt.4.0)n=n+1
      goto 141
c
 113  if(yld.ge.400.0)goto 123
      if(shob.lt.300.0)n=n+1
      goto 200
c
 123  if(shob.le.200.0)n=n+2
      goto 200
c
 115  if(shob.gt.400.0)return
      chk=0.75*y-one
      if(x.lt.chk)return
      goto 200
c
 116  ks=31
c
c  find ksig partitions
c
 141  x45=a(ks+1)+b(ks+1)*shob
      if(xl.le.x45)goto 142
      dsig=0.50
      goto 200
c
 142  x25=a(ks-1)+b(ks-1)*shob
      if(xl.le.x25)dsig=0.20
c
 143  x35=a(ks)+b(ks)*shob
      if(xl.gt.x35)dsig=0.40
      goto 200
c
 144  dsig=0.40
      x45=a(ks)+b(ks)*shob
      if(xl.lt.x45)dsig=0.50
c
 200  k=lk(n)
      il=li(n)
      jl=(lk(n+1)-k)/il
c
      do i=1,il
         c=zero
         do j=1,jl
            k=k+1
            c=c+ch(k)*t(j)
         enddo
         wr=wr+c*s(i)
      enddo
c
      if(wr.lt.zero)wr=zero
      wr=wr*10.0
c
      return
      end
*dk acon
      subroutine acon
*ca real8
*ca const
*ca files
      namelist /conlst/ re,we,g0,ttol
c
c  initialize data
c
      zero       = 0.0
      one        = 1.0
      pi         = 4.0*atan(one)
      twopi      = 2.0*pi
      forpi3     = (4.0*pi)**3
      forpi2     = (4.0*pi)**2
      pi2thd     = 2.0*pi/3.0
      piovr4     = pi/4.0
      third      = one/3.0
      pi886      = pi*0.886
      pi2ov4     = pi*pi/4.0
      pi2o16     = pi*pi/16.0
      trpio4     = 3.0*pi/4.0
      pi4th      = pi**4
      dpr        = 180./pi
      piovr2     = pi/2.0
      cmf        = 30.48
      cnm2ft     = 6076.115
      ckm2ft     = 100000.0/30.48
      cm2ft      = 100.0/30.48
      ckm2ft2    = ckm2ft*ckm2ft
      bk         = 1.38e-23
      cghz2ft    = 2.997e8*3.2808/1.0e9
      small      = 1.0e-8
      cft2cm2    = 30.48*30.48
      xmterg     = 4.186e22
      am         = 2.5e-23
      ei         = 2.24e-11
      ohnft      = 100.0*ckm2ft
      re         = 20902267.0
      we         = 7.29211585e-5
      g0         = 32.174
      ttol       = 1.0e-4
      half       = 0.50
      sqr2pi     = sqrt(2.0*pi)
      spdlig     = 2.99792458e8
c
      read(lin,conlst)
      write(lout,conlst)
c
      twore      = 2.0*re
      re2        = re*re
      rekm       = re/ckm2ft
      rkp100     = rekm+100.0
      rekp120    = rekm+120.0
      rftp100    = rkp100*ckm2ft
      rkp1002    = rkp100*rkp100
      xmu        = g0*re2
      twoxmu     = 2.0*xmu
      xmusqr     = sqrt(xmu)
      cx0        = 6.4*ckm2ft*ckm2ft
      recm       = re*30.48
      grav       = g0*30.48
c
      we4=we
      grav4=grav
      recm4=recm
c
      return
      end
*dk ranf
      function ranf ()  
c   
c  allow cdc compatible random number calls on the vax//convex  
c   
*ca real8   
      real*4 ran
*ca basicd  
      ranf = ran(iseed) 
      return
      end   
